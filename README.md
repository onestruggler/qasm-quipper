# LinguaQuanta

LinguaQuanta is a collection of libraries, tools, and scripts to translate
logical quantum circuits between Quipper and various subsets of the OpenQASM
family of languages. Each translation is designed to be "well-behaved", insofar
that all round-translations are idempotent operations. Furthermore, each parser
in the LinguaQuanta library is a *retraction* to its corresponding code
generator. In practice, this means that using the output of one LinguaQuanta
tool as the input to a second LinguaQuanta tool is equivalent to writing a new
LinguaQuanta tool which composes the underlying code for the two respective
tools. In this way LinguaQuanta provides a family of flexible tools, that
provide reasonable guarentees on their outputs.

# Getting Started

The easiest way to get started with LinguaQuanta is to build the LinguaQuanta
Dockerfile. For more details, see the docker directory. For cases in which the
Dockerfile is insufficient, LinguaQuanta can also be built from source. The
requires the `haskell-platform` package and version at least `3.0` of `cabal`.
When all requirements have been met, build LinguaQuanta by running the
following commands from this directory.
```
cabal update
cabal new-build
cabal new-test
```
If `cabal new-test` does not report any failures, then the installation was
successful.

## Running the Translator Tools

The following instructions assume that you are working from within the
LiguaQuanta Docker container. If you are working outside of a Docker container
are have run `cabal new-build`, then you can find all LinguaQuanta executables
within the `dist-newstyle/build/{os}/{ghc}/LinguaQuanta-{v}/x` directory where
`{os}` and `{ghc}` are determined by your build system and `{v}` is the current
version of LinguaQuanta.

### Translating from Quipper to OpenQASM 3

The simplest use-case of LinguaQuanta is to translate circuits between Quipper
and  OpenQASM 3. For example, we can translate the quantum phase estimation
circuit for the `T` gate from Quipper to OpenQASM 3 using the following
command.
```
quip_to_qasm -s=examples/qpe/qpe.quip
```
The `quip_to_qasm` command translates a Quipper circuit to OpenQASM 3. The
argument `-s` specifies the source file for the translation. By default, the
OpenQASM 3 circuit is written to stdout. The `-o` flag can be used to further
specify an output file. For example, the following command will save the
OpenQASM 3 circuit to `tmp.3.qasm`.
```
quip_to_qasm -s=examples/qpe/qpe.quip -o=tmp.3.qasm
```
In either case, we should return our attention to the OpenQASM 3 program to
observe the differences between standard OpenQASM code and the OpenQASM code
generated by `quip_to_qasm`. Note in particular, that all `QInit0` and
`QDiscard` gates have been replaced by function calls. This allows for more
intelligent "inverse" translation For more details about this encoding, see
the documentation in `libs/quipfuncs.inc`.

### Translating from OpenQASM to Quipper

Likewise, we can translate a quantum phase estimation circuit from OpenQASM 3
to Quipper. In this case we use the `qasm_to_quip` command with the same `-s`
flag set to the OpenQASM file.
```
qasm_to_quip -s=examples/qpe/qpe.3.qasm
```
Translating from OpenQASM 2 to Quipper is just as simple. For example, we can
translate the QFT sub-circuit for quantum phase estimation using the following
command.
```
qasm_to_quip -s=examples/qft/qft.2.qasm
```

### Round-Trip Translations

The translations between OpenQASM 3 and Quipper are not inverses. However, they
do form a [splitting](https://ncatlab.org/nlab/show/split+idempotent) to the
[idempotent](https://ncatlab.org/nlab/show/idempotent) obtained through their
composition. In practice, this means that the translations are "nearly" inverse
operations, and that they are well-behaved under round translations (you will
always end up with the same output no matter how many times you translate the
program).

For example, run the following commands.
```
quip_to_qasm -s=examples/qpe/qpe.quip
quip_to_qasm -s=examples/qpe/qpe.quip | qasm_to_quip
quip_to_qasm -s=examples/qpe/qpe.quip | qasm_to_quip | quip_to_qasm
quip_to_qasm -s=examples/qpe/qpe.quip | qasm_to_quip | quip_to_qasm | qasm_to_quip
```
We can see through these examples that LinguaQuanta translations are invariant
under additional round translations. Note that the when `-s` flag is omitted,
that the input file is assumed to be stdin. Furthermore, observe that when
translating back to Quipper, we recover the `QInit0` and `QDiscard` gates. This
is achieved through use of the `QInit0` and `QDiscard` functions in the
`quipfuncs.inc` library. 

### Translating from Quipper to OpenQASM 2.0

A translation from Quipper to OpenQASM 3 often introduces code fragments not
supported in OpenQASM 2.0, such as gate modifiers and function calls. For this
reasoning, translating from Quipper to OpenQASM 2.0 is not so simple as simply
substituting keywords (e.g., replacing every instance of `qubit` with `qreg`).
The process is spread across several program transformations, which eliminate
control modifiers (`elim_ctrls`), power modifiers (`elim_pows`), inverse
modifiers (`elim_invs`), and function calls (`elim_funs`). The full pipeline is
automated by the `scripts/quip_to_qasm2.sh` script.

To translate the `T` gate quantum phase estimation circuit from Quipper to
OpenQASM 2.0, simply run the following command.
```
scripts/quip_to_qasm2.sh
```
In this script, both the `-s` and `-o` arguments are mandatory. An `-t` flag
is also provided to specify a "temporary directory". If `-t` is set, then the
output of each intermediate transformation will be saved to this directory.

### Translating from Quipper to LSC

To translate from Quipper to the input language of the Lattice Surgery
Compiler, simply use the script `scripts/quip_to_lsc.sh`. The flags to this
script are the same as `scripts/quip_to_qasm2.sh`.

## Unsupported Features

The following features from Quipper are ignored.
- **Comment Gates**: All comment gates are ignored.
- **Global Phase Anchors**: Global phase anchors are discarded. However, global
  phase anchors are only used for PDF generation, so losing this information
  has no impact on the circuit.
- **Generalized Controls**: Generalized controls are demoted to standard input
  wires. This forgets information about the gates, but does not change it
  semantic meaning.
- **No Control Flags**: No control flags are discarded. This is usually okay,
  since no control flags or only required when composing fragments of Quipper
  programs (e.g., when writing a circuit by hand).

The following features from OpenQASM are ignored or unsupported.
- **Comments**: Comments are parsed, but the contents are discarded.
- **Multi-Angle Defcal Statements**: OpenQASM allows end-users to define opaque
  gates with defcal statements. These are unitary operators whose semantics are
  unknown at compile-time. As with hierarchically-defined unitary gates, defcal
  statements may be parameterized by one or more angles. Defcal statements with
  multiple parameters are out of scope, since there is no corresponding notion
  in the Quipper language.
- **OpenPulse and Circuit Timing**: The OpenPulse language and circuit timing
  statements are out of scope since LinguaQuanta targets logical circuits.

The following features are planned for a future release of LinguaQuanta
- **Opaque Gates and Defcals**: In OpenQASM 2.0 the `opaque` annotation was
  used to indicate a unitary gate whose semantics are unknown. In OpenQASM 3,
  the `opaque` annotation was deprecated and replaced by the defcal statement
  without a body. A future version of LinguaQuanta will support both `opaque`
  and `defcal` when used to declare opaque gates. The primary challenge in
  implementing this feature is to change the semantics of `opaque` according to
  the specified version of OpenQASM.
- **Hierarchically-Defined Unitary Gates**: OpenQASM allows users to define new
  unitary gates ("hierarchically-defined unitary gates") in terms of existing
  unitary gates. A future version of LinguaQuanta will parse these gate
  definitions, and inline their implementations before translating the program
  from OpenQASM to Quipper (or the LSC).
- **Classical Control**: In Quipper classical controls are stated explicitly,
  using the control list. In OpenQASM classical controls are implicit, and
  provided through `if`/`else` statements. A future version of LinguaQuanta
  will define a translation between these two models of classical control. It
  is currently unclear how this translation will look, and which expressions
  will be out-of-scope.
- **Constant Propogation**: OpenQASM 3 supports compile-time constant integer
  and floating-point expressions. These expressions are likely to appear in
  real OpenQASM programs. However, translating these programs to Quipper
  requires that we first propogate the constants and inline their symbolic
  values. A future version of LinguaQuanta will provide a tool to perform this
  propogation.
- **Classical Computation**: OpenQASM 3 expresses classical computation in an
  imperative style, using low-level primit ives such as `&&` and `||` operators.
  However, Quipper expresses classical computation at a high-level, using
  opaque classical gates. Further effort is required to define a translation
  between these two models. A future version of LinguaQuanta will support 
- **Power Modifier Optimizations**: The current `elim_pows` simply replaces
  each statement `pow(n) @ g` with `n` copies of `g`. However, most gates in
  OpenQASM are of finite order, or satisfy some relation between powers and
  angles. In these cases, power modifiers could be eliminated using less than
  `n` copies of `g`. A future version of LinguaQuanta will implement these
  optimizations in `elim_pows`.

The following features are neither out-of-scope nor on the roadmap yet.
- **Subroutines**: Quipper allows for a circuit to be "boxed" and then used as
  a subroutine. One challenge in translating subroutines from Quipper to
  OpenQASM is that the qubit overhead must be known a-priori. Since Quipper
  already supports subroutine inlining (circuit unboxing), there are currently
  no plans to support this feature.
- **User-Defined Functions**: OpenQASM 3 allows users to define arbitrary
  functions. However, many properties about these functions (such as the call
  depth) are known to be undecidable in general. Therefore, there are no plans
  to support user-defined functions in general. However, if a subset of these
  functions prove to be useful and reasonable to translate, then they may be
  added to LinguaQuanta in the future.
- **Bounded Iteration**: OpenQASM 3 supports loops and bounded iteration. These
  features are not supported in Quipper (on the circuit level). Since
  LinguaQuanta only interfaces with Quipper on the circuit level, it would be
  challenging to support general loops. However, special cases, such as bounded
  iteration are feasible and could be supported in the future if such use-cases
  were to arise.
